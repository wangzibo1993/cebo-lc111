/* 
  CESYS Software License - Version 1.0 - January 1st, 2016

  Permission is hereby granted, free of charge, to any person or organization
  obtaining a copy of the software and accompanying documentation covered by
  this license (the "Software") to use, reproduce, display, distribute,
  execute, and transmit the Software, and to prepare derivative works of the
  Software, and to permit third-parties to whom the Software is furnished to
  do so, all subject to the following:

  The software must only be used to operate hardware manufactured by 
  CESYS GmbH, Herzogenaurach.

  The copyright notices in the Software and this entire statement, including
  the above license grant, this restriction and the following disclaimer,
  must be included in all copies of the Software, in whole or in part, and
  all derivative works of the Software, unless such copies or derivative
  works are solely in the form of machine-executable object code generated by
  a source language processor.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  Written by Thomas Hoppe <thomas.hoppe@cesys.com>, 2016
*/  

using System;
using System.Collections.Generic;
using System.Text;

namespace CeboMsrNet
{
    /// <summary>
    /// The primary object to communicate with a CeboMsr-compatible device. Every instance holds a single
    /// connection to a device. Instances are created during enumeration in LibraryInterface.Enumerate().
    /// </summary>
    public sealed class Device
    {
        private string _ident, _firmwareVersion;
        private DeviceType _msrType;
        private uint _handle = 0xffffffff;
        private int _maxInputFrames = -1;

        private List<AnalogInput> _singleEnded = new List<AnalogInput>();
        private List<AnalogInput> _differential = new List<AnalogInput>();
        private List<AnalogOutput> _analogOutputs = new List<AnalogOutput>();
        private List<DigitalPort> _digitalPorts = new List<DigitalPort>();
        private List<Counter> _counters = new List<Counter>();
        private List<Trigger> _triggers = new List<Trigger>();
        private List<Led> _leds = new List<Led>();
        private List<CurrentSource> _currentSources = new List<CurrentSource>();

        private int InputFrameFloatCount { get { return _singleEnded.Count + _differential.Count; } }
        private int InputFrameIntCount { get { return _digitalPorts.Count + _counters.Count + _triggers.Count; } }
        private int OutputFrameFloatCount { get { return _analogOutputs.Count; } }
        private int OutputFrameIntCount { get { return _digitalPorts.Count; } }

        private InputFrame BuildInputFrame(float[] vvalues, int[] values, int frameNum)
        {
            int voffset = frameNum * InputFrameFloatCount;
            int offset = frameNum * InputFrameIntCount;
            return new InputFrame(
                vvalues, values,
                voffset, SingleEndedInputs.Count,
                voffset + SingleEndedInputs.Count, DifferentialInputs.Count,
                offset, DigitalPorts.Count,
                offset + DigitalPorts.Count, Counters.Count,
                offset + DigitalPorts.Count + Counters.Count, Triggers.Count);
        }

        internal uint Handle { get { return _handle; } }

        internal Device(string ident, DeviceType msrType, string version)
        {
            _ident = ident;
            _msrType = msrType;
            _firmwareVersion = version;
        }

        /// <summary>
        /// Open device.
        /// </summary>
        public void Open()
        {
            _handle = SystemConnector.Open(_ident);

            _singleEnded.Clear();
            for (int i = 0; i < SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterSingleEndedCount); ++i)
                _singleEnded.Add(new AnalogInput(this, SystemConnector.CeboMsrIoIdSingleEnded0 + (uint)i, AnalogInput.Styles.SingleEnded, i));

            _differential.Clear();
            for (int i = 0; i < SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterDifferentialCount); ++i)
                _differential.Add(new AnalogInput(this, SystemConnector.CeboMsrIoIdDifferential0 + (uint)i, AnalogInput.Styles.Differential, i));

            _analogOutputs.Clear();
            for (int i = 0; i < SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterAnalogOutputCount); ++i)
                _analogOutputs.Add(new AnalogOutput(this, SystemConnector.CeboMsrIoIdAnalogOutput0 + (uint)i, i));

            _digitalPorts.Clear();
            for (int i = 0; i < SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterDigitalPortCount); ++i)
                _digitalPorts.Add(new DigitalPort(this, SystemConnector.CeboMsrIoIdDigitalPort0 + (uint)i, i));

            _counters.Clear();
            for (int i = 0; i < SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterCounterCount); ++i)
                _counters.Add(new Counter(this, SystemConnector.CeboMsrIoIdCounter0 + (uint)i, i));

            _triggers.Clear();
            for (int i = 0; i < SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterTriggerCount); ++i)
                _triggers.Add(new Trigger(this, SystemConnector.CeboMsrIoIdTrigger0 + (uint)i, i));

            _currentSources.Clear();
            for (int i = 0; i < SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterCurrentSourceCount); ++i)
                _currentSources.Add(new CurrentSource(this, SystemConnector.CeboMsrCurrentSource0 + (uint)i, i));

            _leds.Clear();
            for (int i = 0; i < SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterLedCount); ++i)
                _leds.Add(new Led(this, SystemConnector.CeboMsrLedIndicator + (uint)i, 0));

            _maxInputFrames = SystemConnector.GetDeviceParameter(_handle, SystemConnector.CeboParameterMaxInputFrames);
        }

        /// <summary>
        /// Close device.
        /// </summary>
        public void Close()
        {
            SystemConnector.Close(_handle);
        }

        /// <summary>
        /// Restore startup defaults in device.
        /// </summary>
        public void ResetDevice()
        {
            SystemConnector.ResetDevice(_handle);
        }

        /// <summary>
        /// Reset specified elements in device.
        /// </summary>
        /// <param name="mask">Bit vector constructed of Device.FlagReset*</param>
        public void ResetPeripherals(int mask)
        {
            SystemConnector.ResetPeripherals(_handle, mask);
        }

        /// <summary>
        /// Unique id of device.
        /// </summary>
        public string Identifier { get { return _ident; } }

        /// <summary>
        /// Actual type of device.
        /// </summary>
        public DeviceType DeviceType { get { return _msrType; } }

        /// <summary>
        /// The firmware version.
        /// </summary>
        public string FirmwareVersion { get { return _firmwareVersion; } }

        /// <summary>
        /// Serial number of device.
        /// </summary>
        public string SerialNumber { get { return SystemConnector.GetSerialNumber(_handle); } }

        /// <summary>
        /// Read device temperature in degree celsius.
        /// </summary>
        public float Temperature { get { return SystemConnector.GetTemperature(_handle); } }

        /// <summary>
        /// Configure and read the watchdog timer in 250 ms steps, set to 0xffffffff for infinite time.
        /// </summary>
        public uint WatchdogTimeout
        {
            get { return SystemConnector.GetWatchdogTimeout(_handle); }
            set { SystemConnector.SetWatchdogTimeout(_handle, value); }
        }

        /// <summary>
        /// Calculate maximum count of frames that can be buffered on the device when using
        /// multiple frame mode. Depends on the actively selected inputs.
        /// </summary>
        /// <returns>Frame count.</returns>
        public int CalculateMaxBufferedInputFrames()
        {
            return SystemConnector.CalculateMaxBufferedInputFrames(_handle);
        }

        /// <summary>
        /// Define the inputs that were included in the next frame request
        /// (ReadFrame(), ReadBlocking() and ReadNonBlocking()).
        /// </summary>
        /// <param name="inputs">Collection of inputs.</param>
        public void SetupInputFrame(IEnumerable<IInput> inputs)
        {
            List<uint> ios = new List<uint>();
            foreach (IInput input in inputs)
            {
                if (input is AnalogInput)
                    ios.Add((input as AnalogInput).InterfaceId);
                else if (input is DigitalPort)
                    ios.Add((input as DigitalPort).InterfaceId);
                else if (input is Trigger)
                    ios.Add((input as Trigger).InterfaceId);
                else if (input is Counter)
                    ios.Add((input as Counter).InterfaceId);
                else
                    throw new ArgumentException("Unknown input.");
            }
            SystemConnector.SetupInputFrame(_handle, ios.ToArray());
        }

        /// <summary>
        /// Initialize a buffered data acquisition. Frames are buffered in the device memory,
        /// so frame loss is not possible.
        /// </summary>
        /// <param name="frameRate">Frequency in Hz to capture frame.</param>
        /// <param name="frameCount">Maximum count of frames to capture. Maximum possible frames can
        ///               calculated using CalculateMaxBufferedInputFrames().</param>
        /// <param name="externalStarted">If true, sampling starts if an external trigger is detected,
        ///                       immediately otherwise.</param>
        /// <returns>Corrected frame rate.</returns>
        public float StartBufferedDataAcquisition(float frameRate, int frameCount, bool externalStarted)
        {
            if (frameRate <= 0)
                throw new ArgumentException("frameRate must be > 0");
            if (frameCount <= 0)
                throw new ArgumentException("frameCount must be > 0");
            return SystemConnector.StartDataAcquisition(_handle, externalStarted, frameRate, frameCount);
        }

        /// <summary>
        /// Initialize a buffered data acquisition. Frames are buffered in the device memory,
        /// so frame loss is not possible. For every detected trigger, one frame is captured.
        /// Too high frequency on the external trigger will create frame loss.
        /// </summary>
        /// <param name="frameCount">Maximum count of frames to capture. Maximum possible frames can calculated
        ///                   using CalculateMaxBufferedInputFrames()</param>
        public void StartBufferedExternalTimedDataAcquisition(int frameCount)
        {
            if (frameCount <= 0)
                throw new ArgumentException("frameCount must be > 0");
            SystemConnector.StartDataAcquisition(_handle, true, -1, frameCount);
        }

        /// <summary>
        /// Initialize a continuous data acquisition. Data must be read as fast as possible using
        /// ReadBlocking()/ReadNonBlocking(), otherwise  an device buffer overflow may occur.
        /// </summary>
        /// <param name="frameRate">Frequency in Hz to capture frame.</param>
        /// <param name="externalStarted">If true, sampling starts if an external trigger is detected,
        ///                       immediately otherwise.</param>
        /// <returns>Corrected frame rate.</returns>
        public float StartContinuousDataAcquisition(float frameRate, bool externalStarted)
        {
            if (frameRate <= 0)
                throw new ArgumentException("frameRate must be > 0");
            return SystemConnector.StartDataAcquisition(_handle, externalStarted, frameRate, -1);
        }

        /// <summary>
        /// Initialize a continuous data acquisition. Data must be read as fast as possible
        /// using ReadBlocking()/ReadNonBlocking(), otherwise an device buffer overflow may occur.
        /// For every detected trigger, one frame is captured. Too high frequency on the external
        /// trigger will create frame loss.
        /// </summary>
        public void StartContinuousExternalTimedDataAcquisition()
        {
            SystemConnector.StartDataAcquisition(_handle, true, -1, -1);
        }

        /// <summary>
        /// Stop any form of hardware managed data acquisition.
        /// </summary>
        public void StopDataAcquisition()
        {
            SystemConnector.StopDataAcquisition(_handle);
        }

        /// <summary>
        /// Read exact frameCount frames, return after completion, blocks until all data is available.
        /// </summary>
        /// <param name="frameCount">Count of frames to read.</param>
        /// <returns>Collection of read frames.</returns>
        public IList<InputFrame> ReadBlocking(int frameCount)
        {
            float[] vvalues = new float[InputFrameFloatCount * frameCount];
            int[] values = new int[InputFrameIntCount * frameCount];
            SystemConnector.ReadBlocking(_handle, vvalues, values, frameCount);
            List<InputFrame> r = new List<InputFrame>();
            for (int i = 0; i < frameCount; ++i)
                r.Add(BuildInputFrame(vvalues, values, i));
            return r;
        }

        /// <summary>
        /// Read at much possible available frames, return immediately.
        /// </summary>
        /// <returns>Collection of frames available at the moment of reading, 0 <= count <= max possible.</returns>
        public IList<InputFrame> ReadNonBlocking()
        {
            float[] vvalues = new float[InputFrameFloatCount * _maxInputFrames];
            int[] values = new int[InputFrameIntCount * _maxInputFrames];
            int frameCount = SystemConnector.ReadNonBlocking(_handle, vvalues, values);
            List<InputFrame> r = new List<InputFrame>();
            for (int i = 0; i < frameCount; ++i)
                r.Add(BuildInputFrame(vvalues, values, i));
            return r;
        }

        /// <summary>
        /// Read multiple inputs using the previously defined list (SetupInputFrame()).
        /// </summary>
        /// <returns>Frame that contains the values of all specified inputs.</returns>
        public InputFrame ReadFrame()
        {
            float[] vvalues = new float[InputFrameFloatCount];
            int[] values = new int[InputFrameIntCount];
            SystemConnector.ReadFrame(_handle, vvalues, values);
            return BuildInputFrame(vvalues, values, 0);
        }

        /// <summary>
        /// Define the outputs that should be set using the next frame based out transfer.
        /// </summary>
        /// <param name="outputs">Collection of outputs.</param>
        public void SetupOutputFrame(IEnumerable<IOutput> outputs)
        {
            List<uint> ios = new List<uint>();
            foreach (IOutput output in outputs)
            {
                if (output is AnalogOutput)
                    ios.Add((output as AnalogOutput).InterfaceId);
                else if (output is DigitalPort)
                    ios.Add((output as DigitalPort).InterfaceId);
                else
                    throw new ArgumentException("Unknown output.");
            }
            SystemConnector.SetupOutputFrame(_handle, ios.ToArray());
        }

        /// <summary>
        /// Write multiple outputs at once. All outputs specified using SetupOutputFrame() are modified using
        /// the values in the frame.
        /// </summary>
        /// <param name="frame"></param>
        public void WriteFrame(OutputFrame frame)
        {
            SystemConnector.WriteFrame(_handle, frame.VValues, frame.Values);
        }

        /// <summary>
        /// Create OutputFrame instance specific to this device.
        /// </summary>
        /// <returns>New instance of OutputFrame.</returns>
        public OutputFrame CreateOutputFrame()
        {
            return new OutputFrame(OutputFrameFloatCount, OutputFrameIntCount);
        }

        /// <summary>
        /// List of single ended analog inputs.
        /// </summary>
        public IList<AnalogInput> SingleEndedInputs { get { return _singleEnded.AsReadOnly(); } }

        /// <summary>
        /// List of differential analog inputs.
        /// </summary>
        public IList<AnalogInput> DifferentialInputs { get { return _differential.AsReadOnly(); } }

        /// <summary>
        /// List of analog outputs.
        /// </summary>
        public IList<AnalogOutput> AnalogOutputs { get { return _analogOutputs.AsReadOnly(); } }

        /// <summary>
        /// List of digital ports.
        /// </summary>
        public IList<DigitalPort> DigitalPorts { get { return _digitalPorts.AsReadOnly(); } }

        /// <summary>
        /// List of counters.
        /// </summary>
        public IList<Counter> Counters { get { return _counters.AsReadOnly(); } }

        /// <summary>
        /// List of triggers.
        /// </summary>
        public IList<Trigger> Triggers { get { return _triggers.AsReadOnly(); } }

        /// <summary>
        /// List of current sources.
        /// </summary>
        public IList<CurrentSource> CurrentSources { get { return _currentSources.AsReadOnly(); } }

        /// <summary>
        /// List of LED's.
        /// </summary>
        public IList<Led> Leds { get { return _leds.AsReadOnly(); } }

        /// <summary>
        /// Valid flags to use with Device.ResetPeripherals().
        /// </summary>
        public const int FlagResetInputFifo = SystemConnector.CeboMsrPeripheralResetMaskInputFifo;

        public override string ToString()
        {
            return "CeboMsr-Device: " + _ident;
        }
    }
}
